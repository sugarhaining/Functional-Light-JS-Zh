第三章：管理函数入口
---

在第二章的“函数输入”这一节中，我们讨论了函数形参和实参的基础。我们还看到了一些语法上的技巧，来缓解它们使用上的一些问题，比如`...`运算符和解构赋值。

在当时的讨论中，我建议尽可能的尝试设计只有一个参数的函数。但事实上要做到这一点很不容易，你并不会总是控制你需要使用的函数签名。

现在，我们将会把我们的目光转向更为复杂更为强大的模式。用于在这些场景中竞争函数输入。

# 一些在现在，一些在未来
如果一个函数拥有多个实参，你可能马上就需要使用一些参数，同时其余的参数将会被留下来稍后再使用。

思考这个函数：
```JavaScript
function ajax(url,data,callback) {
    // ..
}
```

让我们想象一下吧，你现在要设置几个API的调用，其中URL是预先就知道的，但是处理响应额数据和回调要等会儿才会知道。

当然，你也可以等到当所有的数据都已经知道的时候再调用`ajax(..)`，此时再去引用全局的常量*URL*。但是还有另外一种方法，那就是创建一个已经带有`url`实参的函数引用。

我们要做的是创建一个仍然在底层调用`ajax(..)`的新函数，并且手动将*API URL*设置为第一个实参，然后等待接受另外两个参数。
```JavaScript
function getPerson(data,cb) {
    ajax( "http://some.api/person", data, cb );
}

function getOrder(data,cb) {
    ajax( "http://some.api/order", data, cb );
}
```

手动指定这些函数调用的封装当然是可以的，但它会变得非常冗长，特别是在有不同参数预设的变化时，比如：
```JavaScript
function getCurrentUser(cb) {
    getPerson( { user: CURRENT_USER_ID }, cb );
}
```
在实践中，函数式的编程者们总是习惯于寻找经常重复运用的操作模式，并尝试把这些行为转变为通用的可复用的实用程序。事实上，我相信这已经是许多读者的本能了。所以这并不是只有在函数式编程中才会出现的事情，但是这毫无疑问对于函数式来说非常重要。

为了构思上述这种用于参数预置的实用程序，我们不能仅看上面手动的实现，还需要从概念上来审视它，看看到底发生了什么。

// TODO 这一段存疑
我们一般会这么描述这种模式，`getOrder(data,cb)`函数是`ajax(url,data,cb)`函数的*局部应用(partial application)*。这个术语就是指，输入的实参被*应用于*函数调用时的形参。正如你所看到的，我们只使用了前面的一些参数——特别给`url`形参提供了实参——而剩下的则会在稍后被应用。

对于这种模式稍微正式点的描述是这样的，局部应用能够严格的降低函数的计数值；计数值，是指函数预期形参的输入数量。我们的计数值从原始函数`ajax(..)`的`3`降低到了`getOrder(..)`函数的`2`。

我们再来定义一个实用工具函数`partial(..)`：
```JavaScript
function partial(fn,...presetArgs) {
	return function partiallyApplied(...laterArgs){
		return fn( ...presetArgs, ...laterArgs );
	};
}
```
Tip：上面这个片段可不要看过就完了，稍微花点时间来消化这个程序到底发生了什么，以确保你真的了解了它。这里的这个代码模式实际上会在本书的其它部分一遍又一遍的出现，所以在现在就马上掌握它吧！

`partial(..)`函数接受到了一个局部应用的函数`fn`。然后传入的任何后续实参都会被聚合到`presetArgs`数组中，以备后续使用。

这个函数创建并返回了一个新的内部函数（为了清楚起见，我们称之为`partiallyApplied(..)`），其自身的实参被聚合到了名为`laterArgs`的数组中。

注意到这个内部函数对`fn`和`presetArgs`的引用了吗？这部分是如何工作的呢？在`partial(..)`运行之后，内部函数是如何能够保持对`fn`和`presetArgs`的访问的呢？如果你的答案是*闭包*，恭喜！你答对了！内部函数`partiallyApplied(..)`闭合了`fn`和`presetArgs`变量，所以无论它在哪里运行，它都可以随时访问这两个变量。看到了吗，理解闭包实在是太重要了。

当`partiallyApplied(..)`函数在你的程序的其他地方运行的时候，它将调用闭包中的`fn`来运行原始的函数，拿出一开始局部应用中输入的实参`presetArgs`（在闭包中），然后再使用之后输入的`laterArgs`实参。

如果你觉得有点晕，请停下来重新阅读这里。相信我，在接下来的文本中你会很高兴现在的你这么做了。

作为附注，函数式编程者们通常会喜欢这种代码较短的`=>`箭头函数语法（请参考第一章 “语法”），例如：
```JavaScript
var partial =
	(fn, ...presetArgs) =>
		(...laterArgs) =>
			fn( ...presetArgs, ...laterArgs );
```

现：5001字符
共：46016字符
进度： 10.8%