到现在，我希望你已经对我们使用函数来进行函数式编程的意义有所了解。

一个函数式程序员看待他们程序中的每个函数就像是看到乐高积木那样。他们一眼就认出了这个蓝色的2X2的砖块，并且知道它式如何工作的，以及它们能够做什么。随着他们开始搭建起更大更复杂的模型时，对于他们所需要的每个组件，他们都已经有了从备件中挑选出所需部件的本能。

但是，有时候你会把蓝色的2X2的砖块和灰色的4X4的砖块按照正确的方式放在一起，而且你随之想到：“这是个很有用的组件，我应该会经常用到它。”

所以，现在你构造了一个新的“组件”，这是由另外两个组件组合而来的，你可以在任何你需要的时候通过刚才的方式来构造这个新的组件。在你需要的时候使用这种复合型的蓝灰砖块明显要更有效率，而不是每次都考虑重新组装它们。

函数有着各种各样的形状和尺寸，我们可以定义它们的某种组合，以形成一个新的符合函数，这在程序的各个部分中都很方便。这个一起使用多个函数的过程就被称作*组合 composition*。

# 输出到输入
我们已经看过不少有关组合的例子了。比如，在第三章我们讨论`unary(..)`的时候，我们提到了这个表达式`unary(adder(3))`。想想看这里发生了什么吧。

要组合两个函数，将第一个函数调用的输出作为第二个函数调用的输入。在`unary(adder(3))`中，`adder(3)`调用输出了一个值（一个函数）；然后这个值就被当作实参，直接传递到了`unary(..)`中，它也将返回一个值（另一个函数）。

我们后退一步，将这个数据在概念上的流动状态可视化，大概式这样的：
```
functionValue <-- unary <-- adder <-- 3
```

`3`被输入到了`adder(..)`中，`adder(..)`的输出又被输入到了`unary(..)`中；最后，`unary(..)`的输出是`functionValue`。这就是`unary(..)`和`adder(..)`的组合。

想象一下这样的数据流吧，就像是糖果厂的传送带一样，每个操作都是生产糖果过程中像是冷却、切割、包裹这样的部分。在本章中我们将会用糖果厂的比喻来解释组合到底是什么。

[组合函数的数据流动](https://github.com/getify/Functional-Light-JS/raw/master/fig2.png)

我们先来审视一下动作中的组合。在你的程序中可能会有这样两个工具函数：
```JavaScript
function words(str) {
	return String( str )
		.toLowerCase()
		.split( /\s|\b/ )
		.filter( function alpha(v){
			return /^[\w]+$/.test( v );
		} );
}

function unique(list) {
	var uniqList = [];

	for (let i = 0; i < list.length; i++) {
		// value not yet in the new list?
		if (uniqList.indexOf( list[i] ) === -1 ) {
			uniqList.push( list[i] );
		}
	}

	return uniqList;
}
```

使用这两个工具函数来分析文本字符串：
```JavaScript
var text = "To compose two functions together, pass the \
output of the first function call as the input of the \
second function call.";

var wordsFound = words( text );
var wordsUsed = unique( wordsFound );

wordsUsed;
// ["to","compose","two","functions","together","pass",
// "the","output","of","first","function","call","as",
// "input","second"]
```

我们将`words(..)`的数组输出明明为`wordsFound`。`unique(..)`的输入也是一个数组，所以我们能够将`wordsFound`传输进去。

回到糖果厂的装配线来：第一台机器将会“输入”融化的巧克力，然后它“输出”的是冷却成型的巧克力。装配线上的下一台机器的“输入”则是成型的巧克力块，而它的“输出”则是被切分好的巧克力糖。接下来，线上的另一台机器将取出传送带上的小巧克力糖，然后输出包装好的糖果，并准备打包和运输。

// FIXME: float: right;
[糖果厂生产线 一](https://github.com/getify/Functional-Light-JS/raw/master/fig3.png)

糖果厂因为这个过程变得非常成功，但是与所有的企业一样，管理层一直在寻找新的增长方式。

为了满足更多糖果的生产需求，它们决定去掉传送带装置，并把三个机器堆叠起来，这样一来，上一个机器的输出阀门将会直接连接到下一个机器的输入阀门中。在有传送带的设计中，巧克力块们总是被传送带缓慢且充满噪音的从一个机器送到另一个机器。现在不会再有空间被浪费在传送带上了。

这种创新的设计为工厂的车间节省了很多空间，工厂每天能生产更多的糖果了，管理者们也很高兴。

这个改进的糖果厂配置的代码等于跳过了中间的步骤（之前代码片段中的`wordsFound`变量），然后直接一起使用两个函数调用：
```JavaScript
var wordsUsed = unique( words( text ) );
```
Note: 虽然我们通常阅读函数是从左往右的——`unique(..)`，然后是`words(..)`——但实际的操作顺序应该是从右往左，或者叫从内向外。`words(..)`将会首先运行，然后才是`unique(..)`。稍后我们将会讨论一个新的模式，这个模式的运行顺序符合我们从左向右阅读的自然习惯，它叫做`pipe(..)`。

堆叠起来的机器工作的很顺畅，但是有一些笨重的电线在整个地方挂的到处都是。建造的这些机器越多，工厂车间也就越凌乱。并且，所有这些机器的组装和维护的时间成本将会非常高。

// FIXME: float: left;
[糖果厂生产线 二](https://github.com/getify/Functional-Light-JS/raw/master/fig4.png)

有一天大早，糖果厂的一个工程师有了一个绝妙的点子。假如制造一个箱子来隐藏所有的导线，效率会更高。在箱子里面，三台机器都挂在一起，而从外面看来，一切都是整整齐齐的。在这个花哨的新机器的顶部是一个倒入融化巧克力的阀门，底部是一个吐出包装好了的巧克力糖果的阀门。太棒了！

这个单一的复合机器移动起来非常方便，而且也很容易安装在工厂需要的任何地方。工厂车间中的工人们也觉得很高兴，因为他们不再需要操作三台独立的机器了，他们很快就喜欢上了只操作这个更好的机器。

回到代码中来：现在我们意识到，`words(..)`和`unique(..)`这样成对的，并且是按照特定顺序执行的操作——想象一下复合的乐高积木——我们会在程序的其他部分经常使用到。所以，我们来定义一个符合函数将它们组合起来：
```JavaScript
function uniqueWords(str) {
	return unique( words( str ) );
}
```
`uniqueWords(..)`函数输入字符串，输出一个数组。它是`unique(..)`和`words(..)`的组合，它实现了这样的数据流：
```
wordsUsed <-- unique <-- words <-- text
```
你现在明白了：糖果厂设计的革命性设发展就是函数的组合。

翻译：6804
总共：38227
进度：17%
