到现在，我希望你已经对我们使用函数来进行函数式编程的意义有所了解。

一个函数式程序员看待他们程序中的每个函数就像是看到乐高积木那样。他们一眼就认出了这个蓝色的2X2的砖块，并且知道它式如何工作的，以及它们能够做什么。随着他们开始搭建起更大更复杂的模型时，对于他们所需要的每个组件，他们都已经有了从备件中挑选出所需部件的本能。

但是，有时候你会把蓝色的2X2的砖块和灰色的4X4的砖块按照正确的方式放在一起，而且你随之想到：“这是个很有用的组件，我应该会经常用到它。”

所以，现在你构造了一个新的“组件”，这是由另外两个组件组合而来的，你可以在任何你需要的时候通过刚才的方式来构造这个新的组件。在你需要的时候使用这种复合型的蓝灰砖块明显要更有效率，而不是每次都考虑重新组装它们。

函数有着各种各样的形状和尺寸，我们可以定义它们的某种组合，以形成一个新的符合函数，这在程序的各个部分中都很方便。这个一起使用多个函数的过程就被称作*组合 composition*。

# 输出到输入
我们已经看过不少有关组合的例子了。比如，在第三章我们讨论`unary(..)`的时候，我们提到了这个表达式`unary(adder(3))`。想想看这里发生了什么吧。

要组合两个函数，将第一个函数调用的输出作为第二个函数调用的输入。在`unary(adder(3))`中，`adder(3)`调用输出了一个值（一个函数）；然后这个值就被当作实参，直接传递到了`unary(..)`中，它也将返回一个值（另一个函数）。

我们后退一步，将这个数据在概念上的流动状态可视化，大概式这样的：
```
functionValue <-- unary <-- adder <-- 3
```

`3`被输入到了`adder(..)`中，`adder(..)`的输出又被输入到了`unary(..)`中；最后，`unary(..)`的输出是`functionValue`。这就是`unary(..)`和`adder(..)`的组合。

想象一下这样的数据流吧，就像是糖果厂的传送带一样，每个操作都是生产糖果过程中像是冷却、切割、包裹这样的部分。在本章中我们将会用糖果厂的比喻来解释组合到底是什么。

![组合函数的数据流动](https://github.com/getify/Functional-Light-JS/raw/master/fig2.png)

我们先来审视一下动作中的组合。在你的程序中可能会有这样两个工具函数：
```JavaScript
function words(str) {
	return String( str )
		.toLowerCase()
		.split( /\s|\b/ )
		.filter( function alpha(v){
			return /^[\w]+$/.test( v );
		} );
}

function unique(list) {
	var uniqList = [];

	for (let i = 0; i < list.length; i++) {
		// value not yet in the new list?
		if (uniqList.indexOf( list[i] ) === -1 ) {
			uniqList.push( list[i] );
		}
	}

	return uniqList;
}
```

使用这两个工具函数来分析文本字符串：
```JavaScript
var text = "To compose two functions together, pass the \
output of the first function call as the input of the \
second function call.";

var wordsFound = words( text );
var wordsUsed = unique( wordsFound );

wordsUsed;
// ["to","compose","two","functions","together","pass",
// "the","output","of","first","function","call","as",
// "input","second"]
```

我们将`words(..)`的数组输出明明为`wordsFound`。`unique(..)`的输入也是一个数组，所以我们能够将`wordsFound`传输进去。

回到糖果厂的装配线来：第一台机器将会“输入”融化的巧克力，然后它“输出”的是冷却成型的巧克力。装配线上的下一台机器的“输入”则是成型的巧克力块，而它的“输出”则是被切分好的巧克力糖。接下来，线上的另一台机器将取出传送带上的小巧克力糖，然后输出包装好的糖果，并准备打包和运输。

// FIXME: float: right;
![糖果厂生产线 一](https://github.com/getify/Functional-Light-JS/raw/master/fig3.png)

糖果厂因为这个过程变得非常成功，但是与所有的企业一样，管理层一直在寻找新的增长方式。

为了满足更多糖果的生产需求，它们决定去掉传送带装置，并把三个机器堆叠起来，这样一来，上一个机器的输出阀门将会直接连接到下一个机器的输入阀门中。在有传送带的设计中，巧克力块们总是被传送带缓慢且充满噪音的从一个机器送到另一个机器。现在不会再有空间被浪费在传送带上了。

这种创新的设计为工厂的车间节省了很多空间，工厂每天能生产更多的糖果了，管理者们也很高兴。

这个改进的糖果厂配置的代码等于跳过了中间的步骤（之前代码片段中的`wordsFound`变量），然后直接一起使用两个函数调用：
```JavaScript
var wordsUsed = unique( words( text ) );
```
Note: 虽然我们通常阅读函数是从左往右的——`unique(..)`，然后是`words(..)`——但实际的操作顺序应该是从右往左，或者叫从内向外。`words(..)`将会首先运行，然后才是`unique(..)`。稍后我们将会讨论一个新的模式，这个模式的运行顺序符合我们从左向右阅读的自然习惯，它叫做`pipe(..)`。

堆叠起来的机器工作的很顺畅，但是有一些笨重的电线在整个地方挂的到处都是。建造的这些机器越多，工厂车间也就越凌乱。并且，所有这些机器的组装和维护的时间成本将会非常高。

// FIXME: float: left;
![糖果厂生产线 二](https://github.com/getify/Functional-Light-JS/raw/master/fig4.png)

有一天大早，糖果厂的一个工程师有了一个绝妙的点子。假如制造一个壳子来隐藏所有的导线，效率会更高。在外壳里面，三台机器都挂在一起，而从外面看来，一切都是整整齐齐的。在这个花哨的新机器的顶部是一个倒入融化巧克力的阀门，底部是一个吐出包装好了的巧克力糖果的阀门。太棒了！

这个单一的复合机器移动起来非常方便，而且也很容易安装在工厂需要的任何地方。工厂车间中的工人们也觉得很高兴，因为他们不再需要操作三台独立的机器了，他们很快就喜欢上了只操作这个更好的机器。

回到代码中来：现在我们意识到，`words(..)`和`unique(..)`这样成对的，并且是按照特定顺序执行的操作——想象一下复合的乐高积木——我们会在程序的其他部分经常使用到。所以，我们来定义一个复合函数将它们组合起来：
```JavaScript
function uniqueWords(str) {
	return unique( words( str ) );
}
```
`uniqueWords(..)`函数输入字符串，输出一个数组。它是`unique(..)`和`words(..)`的组合，它实现了这样的数据流：
```
wordsUsed <-- unique <-- words <-- text
```
你现在明白了：糖果厂设计的革命性发展就是函数的组合。

## 机器制造
糖果工厂按部就班嗡嗡嗡的工作着，幸好节省了这么多空间，他们现在有了足够的房间去尝试制作新的糖果了。基于之前的成功经验，同时也为了满足不断增长的糖果种类，管理者们对发明新的复合机器充满了兴趣。

但是工厂的工程师们却很难跟上管理层的要求。因为每当需要制作新型复合机器时，都要花费相当多的时间来制作新的外壳，并将各个机器安装在其中。

因此，工厂工程师们联系了工业化机器供应商以寻求帮助。他们惊奇的轧线，这个供应商提供了一台制造机器的机器！听起来真是难以置信，他们购买了一台机器，这个机器可以将工厂中几台较小的机器——例如巧克力冷却机和切割机——自动连接在一起，并且还在它们周围装上一个漂亮干净的大壳子。这将会让糖果厂的效率真正起飞！

![生产机器的机器](https://github.com/getify/Functional-Light-JS/raw/master/fig5.png)

回到代码中来，我们来构思一个叫`compose2(..)`的工具函数，它能够将两个函数自动组合起来，并且和我们手工操作一模一样：
```JavaScript
function compose2(fn2,fn1) {
	return function composed(origValue){
		return fn2( fn1( origValue ) );
	};
}

// or the ES6 => form
var compose2 =
	(fn2,fn1) =>
		origValue =>
			fn2( fn1( origValue ) );
```
你注意到了吗？我们定义形参的顺序是`fn2, fn1`；此外，列表中的第二个函数（形参名是`fn1`）将会首先运行，然后才是列表中的第一个函数（`fn2`）。换句话说，这些函数是从右往左组成的。

这看起来似乎是个挺奇怪的选择，但是之所以这么做是有原因的。因为大部分典型的函数式库在定义它们的`compose(..)`的时候都是从右往左的顺序，所以我们也延续了这个约定。

// TODO: 此段存疑
但是为什么？我想，比较简单的解释（但是可能并不是历史上最准确的）是这样的，we're listing them to match the order they are written if done manually, or rather the order we encounter them when reading from left-to-right.

`unique(words(str))`按照从左往右的顺序列举出其中的函数，结果是`unique, words`，所以我们可以使用我们的`compose2(..)`工具函数按照上面的顺序接受它们。现在，更有效率的定义糖果制造机的代码是这样的：
```JavaScript
var uniqueWords = compose2( unique, words );
```

## 组合变化
看起来`<-- unique <-- words`的组合是两个函数组合的唯一顺序。但是我们实际上可以按照相反的顺序来组合它们，这样就会创建一个具有不同目的的工具函数：
```JavaScript
var letters = compose2( words, unique );

var chars = letters( "How are you Henry?" );
chars;
// ["h","o","w","a","r","e","y","u","n"]
```
它能够正常工作是因为`words(..)`函数出于对值类型安全性的考虑，它会在一开始就使用`String(..)`把输入转换为字符串。所以`unique(..)`返回的数组——现在是`words(..)`的输入——将会变成字符串`"H,o,w, ,a,r,e,y,u,n,?"`，最后`words(..)`进程中剩余的行为将会把字符串处理成`chars`数组。

我承认，这是个相当取巧的例子。但是关键在于函数组合并不总是单向的。有时候我们把灰色的砖块放在蓝色砖块的顶上，有时候我们又会把蓝色砖块放在上面。

如果糖果厂准备尝试将包装好的糖果放入混合和冷却巧克力的机器，那糖果厂必须要更加小心！

## 常规组合
如果我们可以定义两个函数的组合，那我们当然也能支持任意数量的函数组合。被组合起来的任意数量的函数，它们的可视化数据流如下所示：
```
finalValue <-- func1 <-- func2 <-- ... <-- funcN <-- origValue
```

![最好的机器](https://github.com/getify/Functional-Light-JS/raw/master/fig6.png)

// TODO: 此段存疑
现在，糖果厂拥有了最好的机器：这台机器可以输入任意数量的小型机器，然后吐出更好的大型的机器，这个新的机器能够按照顺序的执行所有步骤。That's one heck of a candy operation!这也是Willy Wonka（译注：美国电影《查理和巧克力工厂》中巧克力工厂的主人）的梦想!

我们可以实现通用的`compose(..)`工具函数：
```JavaScript
function compose(...fns) {
	return function composed(result){
		// copy the array of functions
		var list = fns.slice();

		while (list.length > 0) {
			// take the last function off the end of the list
			// and execute it
			result = list.pop()( result );
		}

		return result;
	};
}

// or the ES6 => form
var compose =
	(...fns) =>
		result => {
			var list = fns.slice();

			while (list.length > 0) {
				// take the last function off the end of the list
				// and execute it
				result = list.pop()( result );
			}

			return result;
		};
```


翻译：11437
总共：38227
进度：30%
