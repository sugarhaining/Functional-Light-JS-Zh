在第二张，我们讨论了函数为何能在`return`某值之外还能有别的输出。到现在为止，你应该对函数的函数式定义非常熟悉了，所以像这样的输出——副作用——你也应该有所耳闻了。

我们将会研究各种形式的副作用，看看它们为什么对我们代码的质量和可读性有害。

在开始之前，我想在这里首先强调一点，本章的中心观点是：写一个没有副作用的程序是不可能的。嗯，也不是不可能，你当然可以，但是这样的程序不会做任何有用的或是者任何可观察到的事情。假如你编写了一个没有副作用的程序，你将无法区分它与一个被删除或者空程序的区别。

函数式编程者们从不消除所有副作用，我们的目的是尽可能的限制它们。为了做到这一点，我们首先需要充分的了解它们。

# Effects On The Side, Please
因果关系：人类可以对我们周围的世界做出最基本最直觉的观察。将一本书从桌子边缘推下去，它就会掉到地上。你并不需要物理学位就能知道，因为你推了书，所以产生了书在重力影响下掉落于地的结果。这是非常清晰和直接的关系。

在程序中，我们同样也是完全处在因果关系中。假如你调用了某个函数（因），它在屏幕中打印出了一条消息（果）。

在阅读程序的时候，读者能否清晰的识别出每个因果关系是非常重要的。在某种程度上，假如不能轻易的看出代码中的因果关系，那么这段程序的可读性就比较低。

思考：
```JavaScript
function foo(x) {
	return x * 2;
}

var y = foo( 3 );
```
在这个很普通的程序中，我们立即就能清楚的知道，调用带着`3`这个值调用`foo`（因），就会返回`6`，并且它会被赋值给`y`（果）。这里没有任何歧义。

但是这个片段：
```JavaScript
function foo(x) {
	y = x * 2;
}

var y;

foo( 3 );
```
这个程序的结果和上面的完全相同，但是却有一个很大的区别，这里的因与果是不相交的，结果是间接达到的。以这种方式设定`y`的值，我们就称之为*副作用*。

<p class="note">
当函数对外部变量进行引用时, 这个变量称为自由变量。并非所有的自由变量引用都是不好的, 但我们要非常小心。
</p>

假如我给你一个引用来调用函数`bar(..)`，并且你并不能看到它的内部代码。但是我告诉你，它没有这样的间接副作用，只有一个显式的`return`，你会怎样？

```JavaScript
bar( 4 );			// 42
```

因为你知道`bar(..)`的内部并不会有任何副作用，所以你能毫无顾忌的像上面这样在任何地方直接调用它。假如你并不知道`bar(..)`是没有副作用的，为了理解调用它的结果，你就必须要去阅读并剖析它所有的逻辑，这对于读者来说是额外的精神负担。

*对于有副作用的函数，其可读性很低。*因为为了理解它你需要付出更多的阅读成本。

我们考虑的更深一些，思考：
```JavaScript
var x = 1;

foo();

console.log( x );

bar();

console.log( x );

baz();

console.log( x );
```
你确定你知道每个`console.log(x)`打印出来的值是多少吗？

正确答案是：完全不知道。因为你根本不确定`foo()`、`bar()`以及`baz()`是否有副作用，你也无法保证在每个步骤中`x`都会被执行，除非你去检查了每个实现，*然后*逐行跟踪程序的前进，随时了解所有的状态变化。

百分比：7%
已翻译：3721
总字符：47346
