# 第二章：函数式函数的基础

函数式编程**并不仅仅意味着使用`function`关键字来进行编程**。如果它就是这么简单，那么这本书到这里就结束的！但不幸的是，函数也的确是函数式编程的核心，而且我们也是使用函数来让代码变得更加*函数式*。

但是，你真的知道*函数*的意义到底是什么吗？

在本章之中，我们将会为本书的其余部分奠定基础，在这里我们将会涵盖函数的所有基础知识。在某种意义上来说，这里的内容是对所有非函数式程序员们所知道的函数知识的回顾。但是如果我们想要更多的学习函数式编程的概念，我们必须对函数*了若指掌*。

不要放弃，因为这里讲述的函数远比你自己知道的要多。

## 函数是什么？

我想我们开始学习函数式编程最自然的方式那就是使用*函数*来编程了。这看起来实在是太简单和明显了，但是我认为我们的旅程需要这坚实的第一步。

所以……函数是什么？

### 数学基础复习

我知道我承诺过我们会尽量远离数学，但是请继续忍受我一会儿，在我们继续之前，先来快速复习一下在代数上有关函数和图像的相关基础知识。

你还记得你在学校里学习的有关`f(x)`的相关知识吗？等式`y = f(x)`在描述什么？

我们像这样定义了一个等式：<code>f(x) = 2x<sup>2</sup> + 3</code>，它的意义是什么？绘制该方程是什么意思？这里就是它的图像：

<img src="https://github.com/getify/Functional-Light-JS/blob/master/fig1.png">

你注意到了吗？对于`x`的任意值，例如`2`，如果你把它带入方程之中，你会得到`11`。但是`11`又是什么？它是函数`f(x)`的*返回值*，这就是我们前面所说的描述的一个`y`值。

换句话来说，在途中的曲线上有一点`(2, 11)`。对于每个我们带入的`x`的值，我们都能得到与之对应的`y`，它们就可以组成一个点的坐标。比如`(0, 3)`，`(-1, 5)`。将所有的这些点放在一起，你就能得到如上图所示的抛物线图形。

所以，这和函数式编程有什么关系呢？

在数学中，一个函数输入了一个值(s)，那么总能够得到一个与之对应的输出。在函数式编程中你常常能听到一个词，叫“态射（morphism）”，这是描述从一组值映射到另一组值的奇特方式，就像是函数的输入和输出的关系。

在代数运算之中，这些输入和输出通常被解释为曲线坐标的一部分。然而，在我们的程序中，我们可以定义各种输入输出的函数，并且它们并不需要与可视的图像曲线有任何关系。

### 函数与过程

为什么我们一直在谈论数学和图像？因为在某种意义上来说，函数式编程中的函数就是数学意义上的函数。

你可能更习惯于将函数当作是过程。它们有什么不同？任意函数功能的集合，它可能有输入，也可能没有；它可能有一个输出（返回值），也可能没有。

函数接受输入，并且一定有一个返回值。

如果你打算做函数式编程，**你应该尽可能多的使用函数**，而不是过程，所有的函数都应该接受输入和返回输出。至于为什么，这个问题的答案将会有很多种层次上的意义，我们将会在书中慢慢解释它。

## 函数输入

从上面的定义来说，所有的函数都需要输入。

你可能时常听到人们常说“实际参数（arguments）”，又或者是“形式参数（parameters）”。他们到底在说什么？

*实际参数*就是指你传进函数的值，*形式参数*是在函数内部的具名变量，它们将会接受这些传进来的值。我们举个例子：
```JavaScript
function foo(x,y) {
    // ..
}

var a = 3;

foo( a, a * 2 );
```

`a`和`a * 2`（实际上应该是这个表达式的结果——`6`）都是`foo(..)`调用的*实际参数*。`x`和`y`都是接受了这些值（分别是`3`和`6`）的*形式参数*。

注：在JavaScript中，并不要求形参和实参的数量一定要匹配。如果你传递的实参多余了你声明的用来接收它们的实参数量，这些值也会被传递，只是你无法直接访问它们。这些值可以通过几种不同的方式来访问，当然也包括你可能已经听说过的`arguments`对象。假设你传递的实参少于了你声明的形参，则每个没有接受实参的形参都将会是个“undefined”变量，就是说在当前的函数作用域中可以找到这个变量，但是它初始化的值是`undefined`。

### 统计输入

函数“期望”的实参数量——你可能想要传递给它的实参数量——是由声明的形参数量决定的。

```JavaScript
function foo(x,y,z) {
    // ..
}
```

`foo(..)`期望三个实参，因为这里有三个声明的形参。这个计数有一个特殊的术语来描述它：计数值（arity）。 计数值是函数声明中的形参数量。`foo（..)`的arity是`3`。

你可能希望在程序运行期间检查函数的形参数量，可以通过该函数引用的`length`属性来完成：
```JavaScript
function foo(x,y,z) {
    // ..
}

foo.length;             // 3
```

为什么会想要在运行期间来确定计数值，是因为可能存在这样的情况，如果一段代码从多个源接收到了某个函数的引用，并且需要根据每个函数引用的计数值，来发送不同的值。

例如，假设一个函数引用`fn`可以接受1个、2个或者是3个实参，但是你总是希望在最后的位置里传输变量`x`：

```JavaScript
// `fn` is set to some function reference
// `x` exists with some value

if (fn.length == 1) {
    fn( x );
}
else if (fn.length == 2) {
    fn( undefined, x );
}
else if (fn.length == 3) {
    fn( undefined, undefined, x );
}
```

提示：`length`属性是只读的，它是在函数声明的时候就已经确定。它应该被认为是一个元数据，因为它描述了函数的预期用途。

有一点需要注意的是，某些种类的形参列表变体可以使函数属性`length`返回的值与你预期的想象不同。别担心，我们将会在本章的后面来解释这些（ES6引入的）功能：
```JavaScript
function foo(x,y = 2) {
    // ..
}

function bar(x,...args) {
    // ..
}

function baz( {a,b} ) {
    // ..
}

foo.length;             // 1
bar.length;             // 1
baz.length;             // 1
```

如果你使用这些形式的形参，一定要小心，函数的`length`值可能会吓到你。

如何计算当前函数调用接受到的实参数量？这在以前是小事儿一桩，但现在情况变得稍微复杂了点。每个函数都有个`arguments`对象（类数组）用来保存对传入的每个参数的引用。然后你可以查看`arguments`的`length`参数来确定实际到底传入了多少个参数：

```JavaScript
function foo(x,y,z) {
    console.log( arguments.length );    // 2
}

foo( 3, 4 );
```

从ES5（具体来说是从严格模式）开始，`arguments`就已经开始被不推荐使用了，很多人也在实际中尽量避免使用它。但是它是永远不会被删除的——在JS中，无论这会多么方便，但我们“绝不”会打破JS向后的兼容性——但是由于各种原因我们强烈建议你在实际中尽量避免使用它。

但是，我个人是建议使用`arguments.length`的。当你需要关注传输进来的实参的数量的时候，但也仅在这个情况下，继续使用这个参数是没有问题的。未来的JS版本可能会添加一个功能，你可以在不依靠`arguments.length`的情况下来确定传递的实参数量。如果真的是这样，那么我们就可以完全抛弃使用`arguments`了。

记住：**绝不**要像`arguments[1]`这样直接以下标来访问实参。如果有必要，坚持只是用`arguments.length`吧。

除非……假如你传递的实参超过了你声明的形参，你要如何访问它们呢？对于这个问题，首先，请先退一步，然后问问你自己：“为什么我要这么做呢？”请你严肃仔细的想一想。

这种情况很少发生，它不应该是你在编程的时候经常期望和依赖的东西。如果你发现自己确实遇到了这样的情况，我建议你花20分钟来尝试设计下与该函数不同的交互方式。即便它是例外，最好也为它命名额外的形参。

接受不确定的自变量函数签名被称为可变函数，有很多人喜欢这种风格的函数设计，但是我想你会发现，通常而言，函数式编程者们一般都想避免这些可能。

好了，在这一点上已经足够了。

有时候你会想要像类数组那样直接用下标来访问实参，发生这种情况很可能是因为你传输进去的实参并没有含有下标的标准化形参来接受它，这时应该怎么办？

ES6来帮忙了！让我们用`...`运算符来声明我们的函数——它有着“扩展运算符”，“其余运算符”，或者（我比较喜欢这个）“聚合运算符”等等称呼。

```JavaScript
function foo(x,y,z,...args) {
    // ..
}
```

看到形参列表里面的`...args`了吗？这是ES6中添加的新的声明形式，它将会告诉引擎收集（或者叫“聚合”）所有剩余的未分配给具名形参的实参，然后把它们放在一个名为`args`的实数数组之中。`args`将始终是个数组，即便它是个空的。但是它不会包括分配给`x`、`y`和`z`的形参值，它只会包括在前三个值以外的所有传递进来的值。

```JavaScript
function foo(x,y,z,...args) {
    console.log( x, y, z, args );
}

foo();                  // undefined undefined undefined []
foo( 1, 2, 3 );         // 1 2 3 []
foo( 1, 2, 3, 4 );      // 1 2 3 [ 4 ]
foo( 1, 2, 3, 4, 5 );   // 1 2 3 [ 4, 5 ]
```

所以，假如你*确实*想要设计一个能够接受可变实参计数值的函数的话，请使用`...args`（或者任何你喜欢的名字）吧。现在，你将有一个真正的，不会丢失参数的数组来访问这些实参了。

只是要注意这样的事情，`4`在`args`数组的下标`0`的位置，而不是下标`3`的位置。并且，它的`length`属性将不会包含`1`，`2`以及`3`。`...args`将会收集所有值，不过当然会除开`x`、`y`以及`z`。

你甚至*能够*直接在形参列表中使用`...`运算符，即便没有声明其他形式的形参：
```JavaScript
function foo(...args) {
    // ..
}
```

现在`args`将会是所有实参的聚合数组，无论它们是什么。而且你可以使用`args.length`来确定到底传入了多少个参数，你也可以安全的直接使用`args[1]`甚至是`args[317]`（如果你可以选的话）。当然，你不要真的传入318个参数就是了。

说到ES6的好东西啊，这里还有些其他的你可能会想知道的关于函数实参和形参的技巧。有关本该数之外的更多信息，请参阅我的另一个系列书籍《你不知道的JS：ES6以及更高版本》。

### 实参的技巧

如果你想把某数组中的所有值作为实参传递进函数调用中怎么办？

```JavaScript
function foo(...args) {
    console.log( args[3] );
}

var arr = [ 1, 2, 3, 4, 5 ];

foo( ...arr );                      // 4
```

我们同样可以使用我们的新朋友`...`，它不仅能用在形参列表中，还能用在函数调用的实参列表中。它在这种情况下的行为刚好相反，在形参列表中它将会将实参们都聚合起来；而在实参列表中，它将会把它们展开。所以，`arr`内的值们将会作为单独的参数传递给`foo(..)`调用。你看到这和传递整个`arr`数组的引用之间的区别了吗？

值得一提的是，`...`运算符和多个值是可以混用的，像这样：
```JavaScript
var arr = [ 2 ];

foo( 1, ...arr, 3, ...[4,5] );      // 4
```

`...`运算符的效果是对称的，在值列表（译注：在这里可以理解为赋值运算的右值）中，它总是*聚合*运算。而在进行赋值运算（译注：在这里可以理解为赋值运算的左值）的地方——像是形参列表，因为实参总是会赋值给形参——它总是*展开*运算。

无论你调用的是什么行为，`...`运算让参数数组使用起来更加容易。想想使用`slice(..)`，`concat(..)`和`apply(..)`来摆弄实参列表的日子吧！我们终于可以和它们说再见了！

### 形参的技巧

从ES6起，形参可以使用默认值声明。在未向该形参传递实参值或者传递了`undefined`的情况下，默认赋值表达式将会代替原来的实参赋值给形参的表达式。

比如：
```JavaScript
function foo(x = 3) {
    console.log( x );
}

foo();                  // 3
foo( undefined );       // 3
foo( null );            // null
foo( 0 );               // 0
```

