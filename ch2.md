# 第二章：函数式函数的基础

函数式编程**并不仅仅意味着使用`function`关键字来进行编程**。如果它就是这么简单，那么这本书到这里就可以结束了！但不幸的是，函数也的确是函数式编程的核心，而且我们也是使用函数来让代码变得更加*函数式*的。

但是，你真的知道*函数*的意义到底是什么吗？

在本章之中，我们将会为本书的其余部分奠定基础，在这里我们将会涵盖函数的所有基础知识。在某种意义上来说，这里的内容是对所有非函数式程序员们所知道的函数知识的回顾。但是如果我们想要更多的学习函数式编程的概念，我们必须对函数*了若指掌*。

不要放弃，因为这里讲述的函数远比你自己知道的要多。

## 函数是什么？

我想我们开始学习函数式编程最自然的方式那就是使用*函数*来编程了。这看起来实在是太简单和明显了，但是我认为我们的旅程需要这坚实的第一步。

所以……函数是什么？

### 数学基础复习

我知道我承诺过我们会尽量远离数学，但是请继续忍受我一会儿，在我们继续之前，先来快速复习一下在代数上有关函数和图像的相关基础知识。

你还记得你在学校里学习的有关`f(x)`的相关知识吗？等式`y = f(x)`在描述什么？

我们像这样定义了一个等式：<code>f(x) = 2x<sup>2</sup> + 3</code>，它的意义是什么？绘制该方程是什么意思？这里就是它的图像：

<img src="https://github.com/getify/Functional-Light-JS/blob/master/fig1.png">

你注意到了吗？对于`x`的任意值，例如`2`，如果你把它带入方程之中，你会得到`11`。但是`11`又是什么？它是函数`f(x)`的*返回值*，这就是我们前面所说的描述的一个`y`值。

换句话来说，在途中的曲线上有一点`(2, 11)`。对于每个我们带入的`x`的值，我们都能得到与之对应的`y`，它们就可以组成一个点的坐标。比如`(0, 3)`，`(-1, 5)`。将所有的这些点放在一起，你就能得到如上图所示的抛物线图形。

所以，这和函数式编程有什么关系呢？

在数学中，一个函数输入了一个值(s)，那么总能够得到一个与之对应的输出。在函数式编程中你常常能听到一个词，叫“态射（morphism）”，这是描述从一组值映射到另一组值的奇特方式，就像是函数的输入和输出的关系。

在代数运算之中，这些输入和输出通常被解释为曲线坐标的一部分。然而，在我们的程序中，我们可以定义各种输入输出的函数，并且它们并不需要与可视的图像曲线有任何关系。

### 函数与过程

为什么我们一直在谈论数学和图像？因为在某种意义上来说，函数式编程中的函数就是数学意义上的函数。

你可能更习惯于将函数当作是过程。它们有什么不同？任意函数功能的集合，它可能有输入，也可能没有；它可能有一个输出（返回值），也可能没有。

函数接受输入，并且一定有一个返回值。

如果你打算做函数式编程，**你应该尽可能多的使用函数**，而不是过程，所有的函数都应该接受输入和返回输出。至于为什么，这个问题的答案将会有很多种层次上的意义，我们将会在书中慢慢解释它。

## 函数输入

从上面的定义来说，所有的函数都需要输入。

你可能时常听到人们常说“实际参数（arguments）”，又或者是“形式参数（parameters）”。他们到底在说什么？

*实际参数*就是指你传进函数的值，*形式参数*是在函数内部的具名变量，它们将会接受这些传进来的值。我们举个例子：
```JavaScript
function foo(x,y) {
    // ..
}

var a = 3;

foo( a, a * 2 );
```

`a`和`a * 2`（实际上应该是这个表达式的结果——`6`）都是`foo(..)`调用的*实际参数*。`x`和`y`都是接受了这些值（分别是`3`和`6`）的*形式参数*。

注：在JavaScript中，并不要求形参和实参的数量一定要匹配。如果你传递的实参多余了你声明的用来接收它们的实参数量，这些值也会被传递，只是你无法直接访问它们。这些值可以通过几种不同的方式来访问，当然也包括你可能已经听说过的`arguments`对象。假设你传递的实参少于了你声明的形参，则每个没有接受实参的形参都将会是个“undefined”变量，就是说在当前的函数作用域中可以找到这个变量，但是它初始化的值是`undefined`。

### 统计输入

函数“期望”的实参数量——你可能想要传递给它的实参数量——是由声明的形参数量决定的。

```JavaScript
function foo(x,y,z) {
    // ..
}
```

`foo(..)`期望三个实参，因为这里有三个声明的形参。这个计数有一个特殊的术语来描述它：计数值（arity）。 计数值是函数声明中的形参数量。`foo（..)`的arity是`3`。

你可能希望在程序运行期间检查函数的形参数量，可以通过该函数引用的`length`属性来完成：
```JavaScript
function foo(x,y,z) {
    // ..
}

foo.length;             // 3
```

为什么会想要在运行期间来确定计数值，是因为可能存在这样的情况，如果一段代码从多个源接收到了某个函数的引用，并且需要根据每个函数引用的计数值，来发送不同的值。

例如，假设一个函数引用`fn`可以接受1个、2个或者是3个实参，但是你总是希望在最后的位置里传输变量`x`：

```JavaScript
// `fn` is set to some function reference
// `x` exists with some value

if (fn.length == 1) {
    fn( x );
}
else if (fn.length == 2) {
    fn( undefined, x );
}
else if (fn.length == 3) {
    fn( undefined, undefined, x );
}
```

提示：`length`属性是只读的，它是在函数声明的时候就已经确定。它应该被认为是一个元数据，因为它描述了函数的预期用途。

有一点需要注意的是，某些种类的形参列表变体可以使函数属性`length`返回的值与你预期的想象不同。别担心，我们将会在本章的后面来解释这些（ES6引入的）功能：
```JavaScript
function foo(x,y = 2) {
    // ..
}

function bar(x,...args) {
    // ..
}

function baz( {a,b} ) {
    // ..
}

foo.length;             // 1
bar.length;             // 1
baz.length;             // 1
```

如果你使用这些形式的形参，一定要小心，函数的`length`值可能会吓到你。

如何计算当前函数调用接受到的实参数量？这在以前是小事儿一桩，但现在情况变得稍微复杂了点。每个函数都有个`arguments`对象（类数组）用来保存对传入的每个参数的引用。然后你可以查看`arguments`的`length`参数来确定实际到底传入了多少个参数：

```JavaScript
function foo(x,y,z) {
    console.log( arguments.length );    // 2
}

foo( 3, 4 );
```

从ES5（具体来说是从严格模式）开始，`arguments`就已经开始被不推荐使用了，很多人也在实际中尽量避免使用它。但是它是永远不会被删除的——在JS中，无论这会多么方便，但我们“绝不”会打破JS向后的兼容性——但是由于各种原因我们强烈建议你在实际中尽量避免使用它。

但是，我个人是建议使用`arguments.length`的。当你需要关注传输进来的实参的数量的时候，但也仅在这个情况下，继续使用这个参数是没有问题的。未来的JS版本可能会添加一个功能，你可以在不依靠`arguments.length`的情况下来确定传递的实参数量。如果真的是这样，那么我们就可以完全抛弃使用`arguments`了。

记住：**绝不**要像`arguments[1]`这样直接用下标来访问实参。如果有必要，坚持只使用`arguments.length`吧。

除非……假如你传递的实参超过了你声明的形参，你要如何访问它们呢？对于这个问题，首先，请先退一步，然后问问你自己：“为什么我要这么做呢？”请你严肃仔细的想一想。

这种情况很少发生，它不应该是你在编程的时候经常期望和依赖的东西。如果你发现自己确实遇到了这样的情况，我建议你花20分钟来尝试设计下与该函数不同的交互方式。即便它是例外，最好也为它命名额外的形参。

接受不确定的自变量函数签名被称为可变函数，有很多人喜欢这种风格的函数设计，但是我想你会发现，通常而言，函数式编程者们一般都想避免这些可能。

好了，在这一点上已经足够了。

有时候你会想要像类数组那样直接用下标来访问实参，发生这种情况很可能是因为你传输进去的实参并没有含有下标的标准化形参来接受它，这时应该怎么办？

ES6来帮忙了！让我们用`...`运算符来声明我们的函数——它有着“扩展运算符”，“其余运算符”，或者（我比较喜欢这个）“聚合运算符”等等称呼。

```JavaScript
function foo(x,y,z,...args) {
    // ..
}
```

看到形参列表里面的`...args`了吗？这是ES6中添加的新的声明形式，它将会告诉引擎收集（或者叫“聚合”）所有剩余的未分配给具名形参的实参，然后把它们放在一个名为`args`的实数数组之中。`args`将始终是个数组，即便它是个空的。但是它不会包括分配给`x`、`y`和`z`的形参值，它只会包括在前三个值以外的所有传递进来的值。

```JavaScript
function foo(x,y,z,...args) {
    console.log( x, y, z, args );
}

foo();                  // undefined undefined undefined []
foo( 1, 2, 3 );         // 1 2 3 []
foo( 1, 2, 3, 4 );      // 1 2 3 [ 4 ]
foo( 1, 2, 3, 4, 5 );   // 1 2 3 [ 4, 5 ]
```

所以，假如你*确实*想要设计一个能够接受可变实参计数值的函数的话，请使用`...args`（或者任何你喜欢的名字）吧。现在，你将有一个真正的，不会丢失参数的数组来访问这些实参了。

只是要注意这样的事情，`4`在`args`数组的下标`0`的位置，而不是下标`3`的位置。并且，它的`length`属性将不会包含`1`，`2`以及`3`。`...args`将会收集所有值，不过当然会除开`x`、`y`以及`z`。

你甚至*能够*直接在形参列表中使用`...`运算符，即便没有声明其他形式的形参：
```JavaScript
function foo(...args) {
    // ..
}
```

现在`args`将会是所有实参的聚合数组，无论它们是什么。而且你可以使用`args.length`来确定到底传入了多少个参数，你也可以安全的直接使用`args[1]`甚至是`args[317]`（如果你可以选的话）。当然，你不要真的传入318个参数就是了。

说到ES6的好东西啊，这里还有些其他的你可能会想知道的关于函数实参和形参的技巧。有关本该数之外的更多信息，请参阅我的另一个系列书籍《你不知道的JS：ES6以及更高版本》。

#### 实参的技巧

如果你想把某数组中的所有值作为实参传递进函数调用中怎么办？

```JavaScript
function foo(...args) {
    console.log( args[3] );
}

var arr = [ 1, 2, 3, 4, 5 ];

foo( ...arr );                      // 4
```

我们同样可以使用我们的新朋友`...`，它不仅能用在形参列表中，还能用在函数调用的实参列表中。它在这种情况下的行为刚好相反，在形参列表中它将会将实参们都聚合起来；而在实参列表中，它将会把它们展开。所以，`arr`内的值们将会作为单独的参数传递给`foo(..)`调用。你看到这和传递整个`arr`数组的引用之间的区别了吗？

值得一提的是，`...`运算符和多个值是可以混用的，像这样：
```JavaScript
var arr = [ 2 ];

foo( 1, ...arr, 3, ...[4,5] );      // 4
```

`...`运算符的效果是对称的，在值列表（译注：在这里可以理解为赋值运算的右值）中，它总是*聚合*运算。而在进行被赋值的地方（译注：在这里可以理解为赋值运算的左值）——像是形参列表，因为实参总是会赋值给形参——它总是*展开*运算。

无论你调用的是什么行为，`...`运算让参数数组使用起来更加容易。想想使用`slice(..)`，`concat(..)`和`apply(..)`来摆弄实参列表的日子吧！我们终于可以和它们说再见了！

#### 形参的技巧

从ES6起，形参可以使用默认值声明。在未向该形参传递实参值或者传递了`undefined`的情况下，默认赋值表达式将会代替原来的实参赋值给形参的表达式。

比如：
```JavaScript
function foo(x = 3) {
    console.log( x );
}

foo();                  // 3
foo( undefined );       // 3
foo( null );            // null
foo( 0 );               // 0
```

Note：我们不会再在这里介绍更多细节了，不过我想要强调一点，默认值表达式是惰性的，这意味着直到必须运行它之前，它都是不会运行的，此外，它允许是任何合法的JS表达式，甚至是函数调用。这样的特性使得它有很多很酷的技巧。比如，你可以在形参列表中声明`x = required()`，然后在`required()`函数中简单的抛出错误`throw "This argument is required."`，这样来确保使用者在调用函数的时候始终指定实参/形参。

在形参中我们还能使用另一种ES6的技巧，它叫做“解构赋值（destructuring）”。我们只会在这里简单的介绍一下，因为它的全部内容比起我们现在涉及到的知识而言要复杂的多。在这里我想再次提一下，关于它更详细的内容，请参考《ES6以及更高版本》这本书。

还记得我们在上面提到的接受了318个实参的函数`foo(..)`吗？
```JavaScript
function foo(...args) {
    // ..
}

foo( ...[1,2,3] );
```

如果我们想要改变这种交互方式，我们想要在函数调用中传入一个值数字组，而不是一个个单独的值，应该怎么做呢？只需要去掉两个`...`运算符就行了：
```JavaScript
function foo(args) {
    // ..
}

foo( [1,2,3] );
```

看起来很简单吧。但是如果我们现在想要给传入的实参数组的前两个值各声明一个形参呢？因为我们没有单独传入实参，所以看起来我们似乎是做不到这种要求的。但是，解构赋值是可以的：
```JavaScript
function foo( [x,y,...args] = [] ) {
    // ..
}

foo( [1,2,3] );
```

你看到在形参列表中的`[..]`括号了吗？这就是数组的解构赋值。解构赋值是一种以声明语句的方式，来描述你希望看到的某些结构体（对象、数组等）的模式，以及如何对其个个部分进行分解（赋值）的方法。

在这个例子中，解构赋值告诉引擎在这个赋值位置（形参）中需要一个数组，并且数组的第一个值会被赋值给当前名为`x`的形参变量，第二值则会赋值给名为`y`的形参变量，而剩下的所有值将会被*聚合*到`args`之中。

你当然也可以像下面这样手动的做同样的事情：
```JavaScript
function foo(params) {
    var x = params[0];
    var y = params[1];
    var args = params.slice( 2 );

    // ..
}
```

在这里我想开始揭示函数式编程的第一个原则，我们之后也将会反复强调下面这句话：声明式的代码通常会比命令式的代码更容易理解。

声明式的代码，就像前面代码片段中的解构赋值，它只关注一段代码的结果应该是什么。命令式的代码，就像刚才显式的手动分配形参变量的做法，则更注重于它是如何获得结果的。如果你以后再来阅读这段代码的时候，你必须在头脑中模拟执行一遍这段代码，来了解结果到底是什么样子的。从这些代码当然也能看出结果，但它终归不是那么清晰明了。

无论语言和我们的库/框架让我们如何如何，只要有可能，**我们都应该努力写出声明式以及自解释性的代码**。

正如我们可以解构数组，我们同样也能够结构对象形参：
```JavaScript
function foo( {x,y} = {} ) {
    console.log( x, y );
}

foo( {
    y: 3
} );                    // undefined 3
```

我们把一个对象作为单个实参传递了进去，然后将之解构成了两个独立的形参`x`和`y`，它们都接受了传入对象与之对应的属性名的值。对象没有`x`这个属性并不是问题，就像你所想的那样，最终这个变量的值将会是`undefined`。

虽然形参是对象解构出来的一部分，但是我希望你能注意这个被传入`foo(..)`的对象本身。

使用像是`foo(undefined, 3)`这样正常的函数调用，参数的位置决定了从实参到形参的映射。我们将`3`放在了第二个位置上，所以它将会赋值给形参`y`。但是在这种使用了形参解构赋值的新式函数调用的情况下，映射是由对象属性来决定的，正如这里形参(`y`)将会被实参值`3`赋值。

我们没有在正常的函数调用中考虑`x`，因为事实上我们并不关心`x`。我们想要忽略它，所以我们必须要额外做一些事情，比如传递`undefined`值作为占位符。

一些语言对此行为有更为直接的功能：命名实参。换句话来说，在函数调用的时候可以直接标记实参，这就能直接指示它应该映射到哪个形参之中。JavaScript中没有命名实参，但是形参对象解构赋值是可以代替它的最好的功能。

使用对象解构赋值来传递参数，比起传递多个参数而言，对于函数式而言是有益处的。只需要一个形参（对象）的函数更容易与另一个单输出的函数相组合。我们将在后面详细解释这一点。

回想一下，计数值这个术语指的是一个函数想要接受多少个形参，计数值的值为`1`的函数也被称作一元函数。在函数式编程中，我们希望我们的函数尽可能的都是一元的，有时候我们甚至会使用各种函数技巧，把具有更多计数值的函数转换为一元的形式。

Note：在第三章，我们将会重新讨论这个命名实参解构赋值的技巧，来解决形参排序这个令人恼人的问题。

### 根据输入而变化的函数

思考下面的函数：
```JavaScript
function foo(x,y) {
    if (typeof x == "number" && typeof y == "number") {
        return x * y;
    }
    else {
        return x + y;
    }
}
```
显然，上面这个例子中的函数将会根据你传递的输入值而发生对应的变化。

比如：
```JavaScript
foo( 3, 4 );            // 12

foo( "3", 4 );          // "34"
```

程序员这样定义函数的原因，是因为将不同的行为重载到单个函数中可能会更加方便。最著名的例子就是`$(..)`函数，它是由JS非常流行的的库jQuery提供的。这个“美元符号”的函数大约有十几种不同的行为——从DOM元素的查找到创建DOM之后为它添加加载完成的回调事件——这些都取决于你传递给它的参数。

我们在学习它的时候能感觉到它最为明显的优势，毕竟它的API实在是简单（只有一个`$(..)`函数）；然而它也有明显的缺点，那就是在阅读代码的时候，我们必须仔细检查传入的参数，然后再去解读这个调用将会做什么。

这种基于输入而表现出不同行为的重载函数的技术，被称做**随意多态**（ad-hoc polymorphism）。

这种设计模式还有另一种表现形式，那就是在不同的场景下使用具有不同的输出（更多的细节将会在下一部分中介绍）。

Warning：一定要小心这里的这种“便利性”的诱惑。因为这样的设计在短期看来可能是有很大优势的，但是它的长期成本可能并不怎么好看。

## 函数的输出
在JavaScript中，函数总会返回一个值。这三个函数都具有相同的返回行为：
```JavaScript
function foo() {}

function bar() {
    return;
}

function baz() {
    return undefined;
}
```
假如你并没有为函数写`return`语句，或者是放了一个空的`return`语句，那么此时将会隐式的返回`undefined`值。

但是为了尽量贯彻函数式函数定义的精神——使用函数而不是过程——我们的函数应该总是有输出的，这意味着它应该显式的返回一个值，而且这个值不应该是`undefined`。

`return`语句只能返回单个值。因此，如果你的函数需要返回多个值，你唯一可行的选择就是将它们聚合成一个复合制，比如数组或对象：
```JavaScript
function foo() {
    var retValue1 = 11;
    var retValue2 = 31;
    return [ retValue1, retValue2 ];
}
```
就像我们在形参中对数组/对象进行解构赋值那样，我们也可以在正常的赋值语句中这么做：
```JavaScript
function foo() {
    var retValue1 = 11;
    var retValue2 = 31;
    return [ retValue1, retValue2 ];
}

var [ x, y ] = foo();
console.log( x + y );           // 42
```
将多个值收集到数组（或者对象）中，把它们当作返回值返回，然后将这些值进行解构赋值，这是一种透明地表达函数多个输出的方式。

Tip：I'd be remiss if I didn't suggest you take a moment to consider if a function needing multiple outputs could be refactored to avoid that, perhaps separated into two or more smaller single-purpose functions? Sometimes that will be possible, sometimes not; but you should at least consider it.

### 提前返回

`return`语句并不只是从函数返回一个值的语句，它也可以当作是个流控制结构；函数将会在这里停止运行。因此当一个拥有多个`return`语句时，这也意味着这个函数拥有多个可能的出口，也意味着假如一个函数拥有多个输出路径，那么要理解函数的输出行为将会更加困难。

比如：
```JavaScript
function foo(x) {
    if (x > 10) return x + 1;

    var y = x / 2;

    if (y > 3) {
        if (x % 2 == 0) return x;
    }

    if (y > 1) return y;

    return x;
}
```
小测验：不要在浏览器中运行代码来作弊哟，请直接回答以下问题，`foo(2)`的返回值是多少？`foo(4)`呢？还有`foo(8)`以及`foo(12)`，以上函数调用的输出分别是多少？

你对你的答案有多少信心？你思考了多长时间呢？I got it wrong the first two times I tried to think it through, and I wrote it!

我认为这里在可读性方面的主要问题是在于，`return`不仅仅是返回了不同的值，还被当作了流控制的语句，用以在某种情况下提前退出函数。很明显，这里有更好的方式来进行流控制（`if`逻辑等），但是我认为也有办法让输出路径更加明显。

Note：这里的答案是`2`、`2`、`8`以及`13`。

思考下面这个版本的代码：
```JavaScript
function foo(x) {
    var retValue;

    if (retValue == undefined && x > 10) {
        retValue = x + 1;
    }

    var y = x / 2;

    if (y > 3) {
        if (retValue == undefined && x % 2 == 0) {
            retValue = x;
        }
    }

    if (retValue == undefined && y > 1) {
        retValue = y;
    }

    if (retValue == undefined) {
        retValue = x;
    }

    return retValue;
}
```
这个版本毫无疑问显得更加繁琐冗长，但是我认为它遵循的逻辑却要显得更加清晰明了，在每个可以给`retValue`赋值的分支中，这个变量已经被*保护*了起来，因为每个分支条件都会对这个变量是否已经被赋值做检查。（译注：只是声明但还没有赋值的变量，其值是`undefined`）

比起在函数中提前`return`，我通常会使用正常的流控制语句（`if`逻辑）来确定`retValue`的赋值。然后在最后直接`return retValue`。

我不是说你必须要无条件的使用单一的`return`，或者是不要提前使用`return`，我只是希望你能在使用`return`的时候小心点，因为它在函数中也是一种隐式的流控制结构。尝试找出最明确的方式来表达逻辑，通常而言，这才是最好的方式。

### Un`return`ed Outputs

(译注：非常对不起……我真不知道这个标题该怎么翻……)

在你编写的大部分代码中你可能试用过一种技术，虽然你可能从来没有注意到它。这个技术就是通过简单的改变外部变量来输出一些或者所有值。

还记得我们在上一章提到的<code>f(x) = 2x<sup>2</sup> + 3</code>函数吗？我们可以在JS中这么定义它：
```JavaScript
var y;

function foo(x) {
    y = (2 * Math.pow( x, 2 )) + 3;
}

foo( 2 );

y;                      // 11
```

我知道这是个非常简单的例子，我们能够很容易的使用`return`返回值的技术，来替代现在这样在函数内直接操作`y`变量的方式：
```JavaScript
function foo(x) {
    return (2 * Math.pow( x, 2 )) + 3;
}

var y = foo( 2 );

y;                      // 11
```
这两个函数能完成相同的任务，我们有什么理由一定要选择后者呢？是的，的确是有的。

这两种方法有一个很明显的区别，那就是后一个版本中使用了`return`语句来显式的输出了值；相对的，前者则是直接给变量`y`赋值，来隐式的输出了这个值。你可能已经有了点感觉，通常而言，开发人员更喜欢显式的模式，而不是隐式的模式。

正如我们在`foo(..)`函数中直接对`y`赋值那样，改变外部作用域中的变量只是实现隐式输出的一种方法。现在还有个更微妙的例子，它是通过引用的方式来修改了非本地的值。

思考：
```JavaScript
function sum(list) {
    var total = 0;
    for (let i = 0; i < list.length; i++) {
        if (!list[i]) list[i] = 0;

        total = total + list[i];
    }

    return total;
}

var nums = [ 1, 3, 9, 27, , 84 ];

sum( nums );            // 124
```

这个函数最明显的输出就是它们的**和**`124`，我们显式的返回了它。但是你找到另一个输出了吗？实时运行这个代码，然后检查`nums`数组吧。现在，你发现不同了吗？

本来在下标为`4`的位置是个`undefined`的空位，但现在那里却是个`0`。看起来无害的`list[i] = 0`操作却影响了外部的数组值，即便我们操作的是一个本地的`list`形参变量。

为什么？因为`list`的值实际上是对于`nums`引用值的引用复制，而并不是其数组内容`[1,3,9,...]`的值复制（译注：这种行为一般称为浅复制）。因为JS对于数组、对象、函数使用的都是其引用以及引用的复制，我们从我们的函数中创建输出实在是非常容易，即便是因为某些意外。

这些隐式的函数输出在函数式编程的世界中有一个特殊的名称：副作用（side effects）。如果一个函数**没有任何副作用**，那么这个函数也有一个特殊的名称：纯函数（pure function）。我们会在后面的章节中更多的讨论这个问题，但是我有忠告，那就是我们更加偏爱于纯函数，而且应该尽可能的避免副作用。