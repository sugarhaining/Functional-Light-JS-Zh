# 第二章：函数式函数的基础

函数式编程**并不仅仅意味着使用`function`关键字来进行编程**。如果它就是这么简单，那么这本书到这里就结束的！但不幸的是，函数也的确是函数式编程的核心，而且我们也是使用函数来让代码变得更加*函数式*。

但是，你真的知道*函数*的意义到底是什么吗？

在本章之中，我们将会为本书的其余部分奠定基础，在这里我们将会涵盖函数的所有基础知识。在某种意义上来说，这里的内容是对所有非函数式程序员们所知道的函数知识的回顾。但是如果我们想要更多的学习函数式编程的概念，我们必须对函数*了若指掌*。

不要放弃，因为这里讲述的函数远比你自己知道的要多。

## 函数是什么？

我想我们开始学习函数式编程最自然的方式那就是使用*函数*来编程了。这看起来实在是太简单和明显了，但是我认为我们的旅程需要这坚实的第一步。

所以……函数是什么？

### 数学基础复习

我知道我承诺过我们会尽量远离数学，但是请继续忍受我一会儿，在我们继续之前，先来快速复习一下在代数上有关函数和图像的相关基础知识。

你还记得你在学校里学习的有关`f(x)`的相关知识吗？等式`y = f(x)`在描述什么？

我们像这样定义了一个等式：<code>f(x) = 2x<sup>2</sup> + 3</code>，它的意义是什么？绘制该方程是什么意思？这里就是它的图像：

<img src="https://github.com/getify/Functional-Light-JS/blob/master/fig1.png">

你注意到了吗？对于`x`的任意值，例如`2`，如果你把它带入方程之中，你会得到`11`。但是`11`又是什么？它是函数`f(x)`的*返回值*，这就是我们前面所说的描述的一个`y`值。

换句话来说，在途中的曲线上有一点`(2, 11)`。对于每个我们带入的`x`的值，我们都能得到与之对应的`y`，它们就可以组成一个点的坐标。比如`(0, 3)`，`(-1, 5)`。将所有的这些点放在一起，你就能得到如上图所示的抛物线图形。

所以，这和函数式编程有什么关系呢？

在数学中，一个函数输入了一个值(s)，那么总能够得到一个与之对应的输出。在函数式编程中你常常能听到一个词，叫“态射（morphism）”，这是描述从一组值映射到另一组值的奇特方式，就像是函数的输入和输出的关系。

在代数运算之中，这些输入和输出通常被解释为曲线坐标的一部分。然而，在我们的程序中，我们可以定义各种输入输出的函数，并且它们并不需要与可视的图像曲线有任何关系。

### 函数与过程

为什么我们一直在谈论数学和图像？因为在某种意义上来说，函数式编程中的函数就是数学意义上的函数。

你可能更习惯于将函数当作是过程。它们有什么不同？任意函数功能的集合，它可能有输入，也可能没有；它可能有一个输出（返回值），也可能没有。

函数接受输入，并且一定有一个返回值。

如果你打算做函数式编程，**你应该尽可能多的使用函数**，而不是过程，所有的函数都应该接受输入和返回输出。至于为什么，这个问题的答案将会有很多种层次上的意义，我们将会在书中慢慢解释它。

## 函数输入

从上面的定义来说，所有的函数都需要输入。

你可能时常听到人们常说“实际参数（arguments）”，又或者是“形式参数（parameters）”。他们到底在说什么？

*实际参数*就是指你传进函数的值，*形式参数*是在函数内部的具名变量，它们将会接受这些传进来的值。我们举个例子：
```JavaScript
function foo(x,y) {
    // ..
}

var a = 3;

foo( a, a * 2 );
```

`a`和`a * 2`（实际上应该是这个表达式的结果——`6`）都是`foo(..)`调用的*实际参数*。`x`和`y`都是接受了这些值（分别是`3`和`6`）的*形式参数*。

注：在JavaScript中，并不要求形参和实参的数量一定要匹配。如果你传递的实参多余了你声明的用来接收它们的实参数量，这些值也会被传递，只是你无法直接访问它们。这些值可以通过几种不同的方式来访问，当然也包括你可能已经听说过的`arguments`对象。假设你传递的实参少于了你声明的形参，则每个没有接受实参的形参都将会是个“undefined”变量，就是说在当前的函数作用域中可以找到这个变量，但是它初始化的值是`undefined`。

### 统计输入

函数“期望”的实参数量——你可能想要传递给它的实参数量——是由声明的形参数量决定的。

```JavaScript
function foo(x,y,z) {
    // ..
}
```

`foo(..)`期望三个实参，因为这里有三个声明的形参。这个计数有一个特殊的术语来描述它：计数值（arity）。 计数值是函数声明中的形参数量。`foo（..)`的arity是`3`。

你可能希望在程序运行期间检查函数的形参数量，可以通过该函数引用的`length`属性来完成：
```JavaScript
function foo(x,y,z) {
    // ..
}

foo.length;             // 3
```

为什么会想要在运行期间来确定计数值，是因为可能存在这样的情况，如果一段代码从多个源接收到了某个函数的引用，并且需要根据每个函数引用的计数值，来发送不同的值。

例如，假设一个函数引用`fn`可以接受1个、2个或者是3个实参，但是你总是希望在最后的位置里传输变量`x`：

```JavaScript
// `fn` is set to some function reference
// `x` exists with some value

if (fn.length == 1) {
    fn( x );
}
else if (fn.length == 2) {
    fn( undefined, x );
}
else if (fn.length == 3) {
    fn( undefined, undefined, x );
}
```

提示：`length`属性是只读的，它是在函数声明的时候就已经确定。它应该被认为是一个元数据，因为它描述了函数的预期用途。

有一点需要注意的是，某些种类的形参列表变体可以使函数属性`length`返回的值与你预期的想象不同。别担心，我们将会在本章的后面来解释这些（ES6引入的）功能：
```JavaScript
function foo(x,y = 2) {
    // ..
}

function bar(x,...args) {
    // ..
}

function baz( {a,b} ) {
    // ..
}

foo.length;             // 1
bar.length;             // 1
baz.length;             // 1
```